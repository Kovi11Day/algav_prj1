package com.algav.patricia;

import com.algav.patricia.exceptions.OutOfCharacterSetException;
import com.algav.patricia.exceptions.PATStringException;
import com.algav.patricia.string.IPATString;
import com.algav.patricia.string.IPATStringE;
import com.algav.patricia.string.IPATWord;
import com.algav.patricia.string.PATString;

public class PatriciaTrie implements IPatriciaTrie{

	private IPATCase[] patTrie;
	private static final int SIZE = 128;
	
	//creer un noeud vide et y ajouter un seul mot
	public PatriciaTrie(String mot){
		this.patTrie = new IPATCase[SIZE];
		
		this.patTrie[asciiFirst(mot)] 
				= new PATCase (concatEpsilon(mot));
	}
	
	public String getWord (int i){
		return this.patTrie[i].getWord();
				
	}
	
	public IPatriciaTrie getSon (int i){
		//if son == null create case
		return this.patTrie[i].getSon();
	}
	
	public IPATCase getCase (int i){
		return this.patTrie[i];
	}
	
	public void setCase (int i, String s){
		this.patTrie[i] = new PATCase(s);
	}
	
	////////***************string_manipulation************************///////////////
	
	public static String stringValid(String s){
		for (int i = 0; i < s.length(); ++i){
			char c = s.charAt(i);
			int ascii = (int)c;
			//on utilise les caracters ASCII d'indice 1 a 127
			if (ascii < 1 || ascii > 127)
				throw new PATStringException("String out of character set\n");
		}
		return s;
	}
	
	//concatenates epsilon at the end of the word
	public static String concatEpsilon (String s){
		
		char epsilon_char = (char)0;
		String epsilon_str = String.valueOf(epsilon_char);
		return s.concat(epsilon_str);
	}
	
	//get ascii code of first character of word
	public static int asciiFirst(String s){
		char c = s.charAt(0);
		return (int)c;
	}
	
	//verify if first character is epsilon
	//note: there cannot be another character after epsilon
	public static boolean firstIsEpsilon(String s) throws PATStringException{
		char first = s.charAt(0);
		int first_ascii = (int)first;
		if (first_ascii == 0){
			if (s.length() > 1){
				throw new 
					PATStringException("Characters after epsilon");
			}
			return true;
		}else{
			return false;
		}
	}
	
	//returns longest common prefixe of 2 strings
	//returns null if none found
	public static String  prefixe(String s1, String s2){
		String result = "";
		int len = Math.min(s1.length(), s2.length());
		for (int i = 0; i < len - 1; ++i){
			if (s1.charAt(i)==s2.charAt(i)){
				result.concat(String.valueOf(s1.charAt(i)));
			}else{
				return null;
			}
		}
		return s1;
	}
	
	/////patricia methods
	//ajout d'un mot dans un patricia trie
	//note: le patricia trie ne peut pas etre vide
	public void ajout(String word){
		sysAjout(concatEpsilon(stringValid(word)));
	}
	
	public void sysAjout (String word){ 
		//cas1
		if (this == null){
			System.out.println("patricia trie is null");
			return;
		}
		//cas2
		if (word.length() == 0){
			return;
		}
		
		//cas3
		if (this.getCase(asciiFirst(word)) == null){
			this.setCase(asciiFirst(word), word);
			return;
		}
	
		//cas4
		//mot dans case prefixe de mot ajouter
		if (word.startsWith(this.getWord(asciiFirst(word)))){
			//get rest of word
			int len = this.getWord(asciiFirst(word)).length();
			String rest = word.substring(len, word.length()-1);
			//ajouter reste du mot dans fils
			this.getSon(asciiFirst(word)).sysAjout(rest);
		}
		
		//cas5
		
			
	}
	
	public static void main(String[] s){
		String s1 = "abcdefk";
		String s2 = "abchi";
		String s3 = "";
		System.out.println(s3.concat(String.valueOf(s1.charAt(0))));
		System.out.println(prefixe(s1,s2));
	}
	
	
}
